"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./services/socket.js":
/*!****************************!*\
  !*** ./services/socket.js ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n\nconst CLEANUP_REASONS = {\n    DISCONNECT: 'disconnect',\n    MANUAL: 'manual',\n    RECONNECT: 'reconnect'\n};\nclass SocketService {\n    async connect() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _this_socket;\n        if (this.connectionPromise) {\n            return this.connectionPromise;\n        }\n        if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n            return Promise.resolve(this.socket);\n        }\n        this.connectionPromise = new Promise((resolve, reject)=>{\n            try {\n                if (this.socket) {\n                    this.cleanup(CLEANUP_REASONS.RECONNECT);\n                }\n                const socketUrl = \"http://localhost:5002\";\n                this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(socketUrl, {\n                    ...options,\n                    transports: [\n                        'websocket',\n                        'polling'\n                    ],\n                    reconnection: true,\n                    reconnectionAttempts: this.maxReconnectAttempts,\n                    reconnectionDelay: this.retryDelay,\n                    reconnectionDelayMax: 5000,\n                    timeout: 20000,\n                    forceNew: true\n                });\n                this.setupEventHandlers(resolve, reject);\n            } catch (error) {\n                this.connectionPromise = null;\n                reject(error);\n            }\n        }).finally(()=>{\n            this.connectionPromise = null;\n        });\n        return this.connectionPromise;\n    }\n    setupEventHandlers(resolve, reject) {\n        const connectionTimeout = setTimeout(()=>{\n            var _this_socket;\n            if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n                reject(new Error('Connection timeout'));\n            }\n        }, 30000);\n        this.socket.on('connect', ()=>{\n            this.connected = true;\n            this.reconnectAttempts = 0;\n            this.isReconnecting = false;\n            clearTimeout(connectionTimeout);\n            this.startHeartbeat();\n            resolve(this.socket);\n        });\n        this.socket.on('disconnect', (reason)=>{\n            this.connected = false;\n            this.cleanup(CLEANUP_REASONS.DISCONNECT);\n        });\n        this.socket.on('connect_error', (error)=>{\n            console.log('Socket connection error:', error.message);\n            if (error.message === 'Invalid session') {\n                reject(error);\n                return;\n            }\n            if (error.message === 'websocket error') {\n                this.reconnectAttempts++;\n            }\n            if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n                clearTimeout(connectionTimeout);\n                reject(error);\n            }\n        });\n        // duplicate_login 이벤트 수신\n        // type: 'new_login_attempt' - 새로 로그인한 디바이스\n        // type: 'existing_session' - 기존 세션이 있던 디바이스 (다른 곳에서 로그인함)\n        this.socket.on('duplicate_login', (data)=>{\n        // TODO: 향후 중복 로그인 처리 필요 시 AuthContext에서 구현\n        });\n        this.socket.on('error', (error)=>{\n            this.handleSocketError(error);\n        });\n        this.socket.on('reconnect', (attemptNumber)=>{\n            this.connected = true;\n            this.reconnectAttempts = 0;\n            this.isReconnecting = false;\n            this.processMessageQueue();\n        });\n        this.socket.on('reconnect_failed', ()=>{\n            this.cleanup(CLEANUP_REASONS.MANUAL);\n            reject(new Error('Reconnection failed'));\n        });\n        this.socket.on('messageReaction', (data)=>{\n            this.reactionHandlers.forEach((handler)=>handler(data));\n        });\n    }\n    cleanup() {\n        let reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : CLEANUP_REASONS.MANUAL;\n        if (reason === CLEANUP_REASONS.DISCONNECT && this.isReconnecting) {\n            return;\n        }\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = null;\n        }\n        if (reason !== CLEANUP_REASONS.RECONNECT) {\n            this.reactionHandlers.clear();\n        }\n        if (reason !== CLEANUP_REASONS.RECONNECT) {\n            this.messageQueue = [];\n        }\n        if (reason === CLEANUP_REASONS.MANUAL && this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        if (reason === CLEANUP_REASONS.MANUAL) {\n            this.reconnectAttempts = 0;\n            this.isReconnecting = false;\n            this.connectionPromise = null;\n            this.connected = false;\n        }\n    }\n    disconnect() {\n        this.cleanup(CLEANUP_REASONS.MANUAL);\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n    }\n    handleConnectionError(error) {\n        this.reconnectAttempts++;\n        if (error.message.includes('auth')) {\n            return;\n        }\n        if (error.message.includes('websocket error')) {\n            if (this.socket) {\n                this.socket.io.opts.transports = [\n                    'polling',\n                    'websocket'\n                ];\n            }\n        }\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            this.cleanup(CLEANUP_REASONS.MANUAL);\n            this.isReconnecting = false;\n        }\n    }\n    handleSocketError(error) {\n        if (error.type === 'TransportError') {\n            this.reconnect();\n        }\n    }\n    startHeartbeat() {\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n        }\n        this.heartbeatInterval = setInterval(()=>{\n            var _this_socket;\n            if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n                this.socket.emit('ping', null, (error)=>{\n                    if (error) {\n                        this.cleanup(CLEANUP_REASONS.MANUAL);\n                    }\n                });\n            } else {\n                this.cleanup(CLEANUP_REASONS.MANUAL);\n            }\n        }, 25000);\n    }\n    getSocket() {\n        return this.socket;\n    }\n    queueMessage(event, data) {\n        const message = {\n            event,\n            data,\n            timestamp: Date.now()\n        };\n        this.messageQueue.push(message);\n    }\n    processMessageQueue() {\n        const now = Date.now();\n        const validMessages = this.messageQueue.filter((msg)=>now - msg.timestamp < 300000);\n        while(validMessages.length > 0){\n            const message = validMessages.shift();\n            try {\n                this.socket.emit(message.event, message.data);\n            } catch (error) {\n            // Silent error handling\n            }\n        }\n        this.messageQueue = validMessages;\n    }\n    async emit(event, data) {\n        try {\n            var _this_socket;\n            if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n                await this.connect();\n            }\n            return new Promise((resolve, reject)=>{\n                var _this_socket;\n                if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n                    reject(new Error('Socket is not connected'));\n                    return;\n                }\n                const timeout = setTimeout(()=>{\n                    reject(new Error('Socket event timeout'));\n                }, 10000);\n                this.socket.emit(event, data, (response)=>{\n                    clearTimeout(timeout);\n                    if (response === null || response === void 0 ? void 0 : response.error) {\n                        reject(response.error);\n                    } else {\n                        resolve(response);\n                    }\n                });\n            });\n        } catch (error) {\n            this.queueMessage(event, data);\n            throw error;\n        }\n    }\n    on(event, callback) {\n        if (!this.socket) {\n            this.messageHandlers.set(event, callback);\n            return;\n        }\n        this.socket.on(event, callback);\n    }\n    off(event, callback) {\n        if (!this.socket) {\n            this.messageHandlers.delete(event);\n            return;\n        }\n        this.socket.off(event, callback);\n    }\n    async reconnect() {\n        if (this.isReconnecting) return;\n        this.isReconnecting = true;\n        this.cleanup(CLEANUP_REASONS.RECONNECT);\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        try {\n            await new Promise((resolve)=>setTimeout(resolve, this.retryDelay));\n            await this.connect();\n        } catch (error) {\n            this.isReconnecting = false;\n            throw error;\n        }\n    }\n    isConnected() {\n        var _this_socket;\n        return this.connected && ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected);\n    }\n    getConnectionQuality() {\n        var _this_socket, _this_socket_conn_transport, _this_socket_conn;\n        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) return 'disconnected';\n        if (this.isReconnecting) return 'reconnecting';\n        if (((_this_socket_conn = this.socket.conn) === null || _this_socket_conn === void 0 ? void 0 : (_this_socket_conn_transport = _this_socket_conn.transport) === null || _this_socket_conn_transport === void 0 ? void 0 : _this_socket_conn_transport.name) === 'polling') return 'poor';\n        return 'good';\n    }\n    async addReaction(messageId, reaction, user) {\n        try {\n            if (!user) {\n                throw new Error('Authentication required');\n            }\n            await this.emit('messageReaction', {\n                messageId,\n                reaction,\n                add: true\n            });\n        } catch (error) {\n            throw error;\n        }\n    }\n    async removeReaction(messageId, reaction, user) {\n        try {\n            if (!user) {\n                throw new Error('Authentication required');\n            }\n            await this.emit('messageReaction', {\n                messageId,\n                reaction,\n                add: false\n            });\n        } catch (error) {\n            throw error;\n        }\n    }\n    onReactionUpdate(handler) {\n        if (typeof handler !== 'function') {\n            throw new Error('Handler must be a function');\n        }\n        this.reactionHandlers.add(handler);\n        return ()=>this.reactionHandlers.delete(handler);\n    }\n    async toggleReaction(messageId, reaction, user) {\n        try {\n            if (!user) {\n                throw new Error('Authentication required');\n            }\n            await this.emit('messageReaction', {\n                messageId,\n                reaction,\n                toggle: true\n            });\n        } catch (error) {\n            throw error;\n        }\n    }\n    constructor(){\n        this.socket = null;\n        this.heartbeatInterval = null;\n        this.messageHandlers = new Map();\n        this.messageQueue = [];\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        this.isReconnecting = false;\n        this.connectionPromise = null;\n        this.retryDelay = 3000;\n        this.reactionHandlers = new Set();\n        this.connected = false;\n    }\n}\nconst socketService = new SocketService();\nif (true) {\n    window.addEventListener('online', ()=>{\n        if (!socketService.isConnected() && !socketService.isReconnecting) {\n            socketService.connect();\n        }\n    });\n    window.addEventListener('offline', ()=>{\n        socketService.disconnect();\n    });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socketService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN6QixJQUFJLENBQUMwQixlQUFlLEdBQUcsSUFBSWtCO1FBQzNCLElBQUksQ0FBQ3pDLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ2xCLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ2Isb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDYyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDNUIsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDZ0IsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ3VCLGdCQUFnQixHQUFHLElBQUlnRDtRQUM1QixJQUFJLENBQUNyRixTQUFTLEdBQUc7SUFDbkI7QUE4VkY7QUFFQSxNQUFNc0YsZ0JBQWdCLElBQUkzRjtBQUUxQixJQUFJLElBQTZCLEVBQUU7SUFDakM0RixPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVO1FBQ2hDLElBQUksQ0FBQ0YsY0FBY2hCLFdBQVcsTUFBTSxDQUFDZ0IsY0FBYzVELGNBQWMsRUFBRTtZQUNqRTRELGNBQWMxRixPQUFPO1FBQ3ZCO0lBQ0Y7SUFFQTJGLE9BQU9DLGdCQUFnQixDQUFDLFdBQVc7UUFDakNGLGNBQWMxQyxVQUFVO0lBQzFCO0FBQ0Y7QUFFQSxpRUFBZTBDLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdW5zZW9wYXJrL0Rlc2t0b3Ava3RiLUJvb3RjYW1wQ2hhdC9hcHBzL2Zyb250ZW5kL3NlcnZpY2VzL3NvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbyB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuXG5jb25zdCBDTEVBTlVQX1JFQVNPTlMgPSB7XG4gIERJU0NPTk5FQ1Q6ICdkaXNjb25uZWN0JyxcbiAgTUFOVUFMOiAnbWFudWFsJyxcbiAgUkVDT05ORUNUOiAncmVjb25uZWN0J1xufTtcblxuY2xhc3MgU29ja2V0U2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMgPSA1O1xuICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSAzMDAwO1xuICAgIHRoaXMucmVhY3Rpb25IYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdChvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zb2NrZXQpO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXAoQ0xFQU5VUF9SRUFTT05TLlJFQ09OTkVDVCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb2NrZXRVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TT0NLRVRfVVJMO1xuXG4gICAgICAgIHRoaXMuc29ja2V0ID0gaW8oc29ja2V0VXJsLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB0cmFuc3BvcnRzOiBbJ3dlYnNvY2tldCcsICdwb2xsaW5nJ10sXG4gICAgICAgICAgcmVjb25uZWN0aW9uOiB0cnVlLFxuICAgICAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzLFxuICAgICAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiB0aGlzLnJldHJ5RGVsYXksXG4gICAgICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDUwMDAsXG4gICAgICAgICAgdGltZW91dDogMjAwMDAsXG4gICAgICAgICAgZm9yY2VOZXc6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXR1cEV2ZW50SGFuZGxlcnMocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gbnVsbDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICB9XG5cbiAgc2V0dXBFdmVudEhhbmRsZXJzKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ29ubmVjdGlvbiB0aW1lb3V0JykpO1xuICAgICAgfVxuICAgIH0sIDMwMDAwKTtcblxuICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgdGhpcy5zdGFydEhlYXJ0YmVhdCgpO1xuICAgICAgcmVzb2x2ZSh0aGlzLnNvY2tldCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNvY2tldC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmNsZWFudXAoQ0xFQU5VUF9SRUFTT05TLkRJU0NPTk5FQ1QpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBzZXNzaW9uJykge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ3dlYnNvY2tldCBlcnJvcicpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA+PSB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBkdXBsaWNhdGVfbG9naW4g7J2067Kk7Yq4IOyImOyLoFxuICAgIC8vIHR5cGU6ICduZXdfbG9naW5fYXR0ZW1wdCcgLSDsg4jroZwg66Gc6re47J247ZWcIOuUlOuwlOydtOyKpFxuICAgIC8vIHR5cGU6ICdleGlzdGluZ19zZXNzaW9uJyAtIOq4sOyhtCDshLjshZjsnbQg7J6I642YIOuUlOuwlOydtOyKpCAo64uk66W4IOqzs+yXkOyEnCDroZzqt7jsnbjtlagpXG4gICAgdGhpcy5zb2NrZXQub24oJ2R1cGxpY2F0ZV9sb2dpbicsIChkYXRhKSA9PiB7XG4gICAgICAvLyBUT0RPOiDtlqXtm4Qg7KSR67O1IOuhnOq3uOyduCDsspjrpqwg7ZWE7JqUIOyLnCBBdXRoQ29udGV4dOyXkOyEnCDqtaztmIRcbiAgICB9KTtcblxuICAgIHRoaXMuc29ja2V0Lm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVTb2NrZXRFcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNvY2tldC5vbigncmVjb25uZWN0JywgKGF0dGVtcHROdW1iZXIpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZVF1ZXVlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNvY2tldC5vbigncmVjb25uZWN0X2ZhaWxlZCcsICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYW51cChDTEVBTlVQX1JFQVNPTlMuTUFOVUFMKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1JlY29ubmVjdGlvbiBmYWlsZWQnKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNvY2tldC5vbignbWVzc2FnZVJlYWN0aW9uJywgKGRhdGEpID0+IHtcbiAgICAgIHRoaXMucmVhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcihkYXRhKSk7XG4gICAgfSk7XG4gIH1cblxuICBjbGVhbnVwKHJlYXNvbiA9IENMRUFOVVBfUkVBU09OUy5NQU5VQUwpIHtcbiAgICBpZiAocmVhc29uID09PSBDTEVBTlVQX1JFQVNPTlMuRElTQ09OTkVDVCAmJiB0aGlzLmlzUmVjb25uZWN0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRJbnRlcnZhbCk7XG4gICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocmVhc29uICE9PSBDTEVBTlVQX1JFQVNPTlMuUkVDT05ORUNUKSB7XG4gICAgICB0aGlzLnJlYWN0aW9uSGFuZGxlcnMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAocmVhc29uICE9PSBDTEVBTlVQX1JFQVNPTlMuUkVDT05ORUNUKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgIH1cblxuICAgIGlmIChyZWFzb24gPT09IENMRUFOVVBfUkVBU09OUy5NQU5VQUwgJiYgdGhpcy5zb2NrZXQpIHtcbiAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocmVhc29uID09PSBDTEVBTlVQX1JFQVNPTlMuTUFOVUFMKSB7XG4gICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuY2xlYW51cChDTEVBTlVQX1JFQVNPTlMuTUFOVUFMKTtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDb25uZWN0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XG5cbiAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnYXV0aCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3dlYnNvY2tldCBlcnJvcicpKSB7XG4gICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuaW8ub3B0cy50cmFuc3BvcnRzID0gWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzID49IHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgIHRoaXMuY2xlYW51cChDTEVBTlVQX1JFQVNPTlMuTUFOVUFMKTtcbiAgICAgIHRoaXMuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTb2NrZXRFcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvci50eXBlID09PSAnVHJhbnNwb3J0RXJyb3InKSB7XG4gICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0SGVhcnRiZWF0KCkge1xuICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdwaW5nJywgbnVsbCwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoQ0xFQU5VUF9SRUFTT05TLk1BTlVBTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xlYW51cChDTEVBTlVQX1JFQVNPTlMuTUFOVUFMKTtcbiAgICAgIH1cbiAgICB9LCAyNTAwMCk7XG4gIH1cblxuICBnZXRTb2NrZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ja2V0O1xuICB9XG5cbiAgcXVldWVNZXNzYWdlKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgZXZlbnQsIGRhdGEsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gIH1cblxuICBwcm9jZXNzTWVzc2FnZVF1ZXVlKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdmFsaWRNZXNzYWdlcyA9IHRoaXMubWVzc2FnZVF1ZXVlLmZpbHRlcihtc2cgPT4gbm93IC0gbXNnLnRpbWVzdGFtcCA8IDMwMDAwMCk7XG5cbiAgICB3aGlsZSAodmFsaWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdmFsaWRNZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zb2NrZXQuZW1pdChtZXNzYWdlLmV2ZW50LCBtZXNzYWdlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gU2lsZW50IGVycm9yIGhhbmRsaW5nXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSB2YWxpZE1lc3NhZ2VzO1xuICB9XG5cbiAgYXN5bmMgZW1pdChldmVudCwgZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NvY2tldCBpcyBub3QgY29ubmVjdGVkJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTb2NrZXQgZXZlbnQgdGltZW91dCcpKTtcbiAgICAgICAgfSwgMTAwMDApO1xuXG4gICAgICAgIHRoaXMuc29ja2V0LmVtaXQoZXZlbnQsIGRhdGEsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICBpZiAocmVzcG9uc2U/LmVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMucXVldWVNZXNzYWdlKGV2ZW50LCBkYXRhKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5zb2NrZXQpIHtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLnNldChldmVudCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc29ja2V0Lm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gIH1cblxuICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnNvY2tldCkge1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMuZGVsZXRlKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNvY2tldC5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGFzeW5jIHJlY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5pc1JlY29ubmVjdGluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5pc1JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdGhpcy5jbGVhbnVwKENMRUFOVVBfUkVBU09OUy5SRUNPTk5FQ1QpO1xuXG4gICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnNvY2tldCA9IG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLnJldHJ5RGVsYXkpKTtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWQgJiYgdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZDtcbiAgfVxuXG4gIGdldENvbm5lY3Rpb25RdWFsaXR5KCkge1xuICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkgcmV0dXJuICdkaXNjb25uZWN0ZWQnO1xuICAgIGlmICh0aGlzLmlzUmVjb25uZWN0aW5nKSByZXR1cm4gJ3JlY29ubmVjdGluZyc7XG4gICAgaWYgKHRoaXMuc29ja2V0LmNvbm4/LnRyYW5zcG9ydD8ubmFtZSA9PT0gJ3BvbGxpbmcnKSByZXR1cm4gJ3Bvb3InO1xuICAgIHJldHVybiAnZ29vZCc7XG4gIH1cblxuICBhc3luYyBhZGRSZWFjdGlvbihtZXNzYWdlSWQsIHJlYWN0aW9uLCB1c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuZW1pdCgnbWVzc2FnZVJlYWN0aW9uJywge1xuICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgIHJlYWN0aW9uLFxuICAgICAgICBhZGQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW1vdmVSZWFjdGlvbihtZXNzYWdlSWQsIHJlYWN0aW9uLCB1c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuZW1pdCgnbWVzc2FnZVJlYWN0aW9uJywge1xuICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgIHJlYWN0aW9uLFxuICAgICAgICBhZGQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgb25SZWFjdGlvblVwZGF0ZShoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMucmVhY3Rpb25IYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMucmVhY3Rpb25IYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG4gIH1cblxuICBhc3luYyB0b2dnbGVSZWFjdGlvbihtZXNzYWdlSWQsIHJlYWN0aW9uLCB1c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuZW1pdCgnbWVzc2FnZVJlYWN0aW9uJywge1xuICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgIHJlYWN0aW9uLFxuICAgICAgICB0b2dnbGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc29ja2V0U2VydmljZSA9IG5ldyBTb2NrZXRTZXJ2aWNlKCk7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgKCkgPT4ge1xuICAgIGlmICghc29ja2V0U2VydmljZS5pc0Nvbm5lY3RlZCgpICYmICFzb2NrZXRTZXJ2aWNlLmlzUmVjb25uZWN0aW5nKSB7XG4gICAgICBzb2NrZXRTZXJ2aWNlLmNvbm5lY3QoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgKCkgPT4ge1xuICAgIHNvY2tldFNlcnZpY2UuZGlzY29ubmVjdCgpO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc29ja2V0U2VydmljZTtcbiJdLCJuYW1lcyI6WyJpbyIsIkNMRUFOVVBfUkVBU09OUyIsIkRJU0NPTk5FQ1QiLCJNQU5VQUwiLCJSRUNPTk5FQ1QiLCJTb2NrZXRTZXJ2aWNlIiwiY29ubmVjdCIsIm9wdGlvbnMiLCJjb25uZWN0aW9uUHJvbWlzZSIsInNvY2tldCIsImNvbm5lY3RlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2xlYW51cCIsInNvY2tldFVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TT0NLRVRfVVJMIiwidHJhbnNwb3J0cyIsInJlY29ubmVjdGlvbiIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwibWF4UmVjb25uZWN0QXR0ZW1wdHMiLCJyZWNvbm5lY3Rpb25EZWxheSIsInJldHJ5RGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInRpbWVvdXQiLCJmb3JjZU5ldyIsInNldHVwRXZlbnRIYW5kbGVycyIsImVycm9yIiwiZmluYWxseSIsImNvbm5lY3Rpb25UaW1lb3V0Iiwic2V0VGltZW91dCIsIkVycm9yIiwib24iLCJyZWNvbm5lY3RBdHRlbXB0cyIsImlzUmVjb25uZWN0aW5nIiwiY2xlYXJUaW1lb3V0Iiwic3RhcnRIZWFydGJlYXQiLCJyZWFzb24iLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsImRhdGEiLCJoYW5kbGVTb2NrZXRFcnJvciIsImF0dGVtcHROdW1iZXIiLCJwcm9jZXNzTWVzc2FnZVF1ZXVlIiwicmVhY3Rpb25IYW5kbGVycyIsImZvckVhY2giLCJoYW5kbGVyIiwiaGVhcnRiZWF0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xlYXIiLCJtZXNzYWdlUXVldWUiLCJkaXNjb25uZWN0IiwiaGFuZGxlQ29ubmVjdGlvbkVycm9yIiwiaW5jbHVkZXMiLCJvcHRzIiwidHlwZSIsInJlY29ubmVjdCIsInNldEludGVydmFsIiwiZW1pdCIsImdldFNvY2tldCIsInF1ZXVlTWVzc2FnZSIsImV2ZW50IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInB1c2giLCJ2YWxpZE1lc3NhZ2VzIiwiZmlsdGVyIiwibXNnIiwibGVuZ3RoIiwic2hpZnQiLCJyZXNwb25zZSIsImNhbGxiYWNrIiwibWVzc2FnZUhhbmRsZXJzIiwic2V0Iiwib2ZmIiwiZGVsZXRlIiwiaXNDb25uZWN0ZWQiLCJnZXRDb25uZWN0aW9uUXVhbGl0eSIsImNvbm4iLCJ0cmFuc3BvcnQiLCJuYW1lIiwiYWRkUmVhY3Rpb24iLCJtZXNzYWdlSWQiLCJyZWFjdGlvbiIsInVzZXIiLCJhZGQiLCJyZW1vdmVSZWFjdGlvbiIsIm9uUmVhY3Rpb25VcGRhdGUiLCJ0b2dnbGVSZWFjdGlvbiIsInRvZ2dsZSIsIk1hcCIsIlNldCIsInNvY2tldFNlcnZpY2UiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./services/socket.js\n"));

/***/ })

});